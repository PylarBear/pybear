import numpy as n
from ML_PACKAGE._data_validation import validate_modified_object_type as vmot, ValidateCharSeqDataType as vcsdt


# modified_object_type IS THE "TYPE" PULLED FROM THE PYTHON TYPE ---- str(type(OBJECT))
# object_type IS GROUPINGS OF modified_object_type, CHAR_SEQs, LISTTYPES, ET AL (USED FOR SIMPLICITY OF IF STATEMENTS)
# data_type IS THE "TYPE" GENERATED BY ValidateCharSeqDataType
#

# CALLED ONLY BY ValidateObjectType, SEVERAL TIMES
class ValidateList():
    def __init__(self, LIST_OBJECT):
        self.LIST_OBJECT = LIST_OBJECT
        self.OBJECT = LIST_OBJECT
        self.LEOUD = []  #LIST_ENTIRE_OBJECT_UNIQUE_DATATYPES
        self.LFIUD = []  #LIST_FIRST_IDXPOSN_UNIQUE_DATATYPES
        self.LSIUD = []  #LIST_SECOND_IDXPOSN_UNIQUE_DATATYPES
        self.LOTD = [] #LIST_OF_TYPE_DESCRIPTIONS
        if vmot.validate_modified_object_type(self.LIST_OBJECT) not in vmot.list_of_listtypes():
            print(f'Object going into ValidateList is not a list-type.  Disaster.')

        self.UNIQUES = []

    def append_LEOUD(self, _):
        if _ not in self.LEOUD:
            self.LEOUD.append(_)


    def append_LFIUD(self, _):
        if _ not in self.LFIUD:
            self.LFIUD.append(_)


    def append_LSIUD(self, _, __):
        if _ not in self.LSIUD[__]:
            self.LSIUD[__].append(_)


    def run(self):
        self.modified_object_type = vmot.validate_modified_object_type(self.LIST_OBJECT)

        if self.modified_object_type.upper() not in vmot.list_of_listtypes():
            raise TypeError(f'OBJECT GOING INTO ValidateList IS NOT A LIST-TYPE OBJECT')

        while True:
            xxx = self.modified_object_type.upper()  # OUTER TYPE
            if len(self.LIST_OBJECT) == 0:
                self.list_type_desc = f'EMPTY {xxx}'  # <===================================================
                # NO CHANGE TO LEOUD
                # NO CHANGE TO LFIUD
                # NO CHANGE TO LSIUD
                # No CHANGE TO LTOD
                break

            elif len(self.LIST_OBJECT) > 0:
                # FIND OUT WHAT PYTHON-TYPES ARE IN THE OUTER LIST AND PUT INSIDE LFIUD, IF A CHAR-TYPE JUST PUT IN ONE "CHAR_SEQ"
                # INDICATOR IN PLACE OF ALL THE VARIOUS CHARSEQS
                for _ in self.LIST_OBJECT:  # DOING IT OUT LIKE THIS INSTD OF append_LFIUD() BECAUSE THE REPLACEMENT OF THE OBJECT TYPE
                    first_inside_type = vmot.validate_modified_object_type(_).upper()    # WITH 'CHAR_SEQ' IS AN ODDBALL OPERATION

                    if first_inside_type in vmot.list_of_charseqs():
                        self.append_LFIUD('CHAR_SEQ') # REPLACING ANY CHAR_SEQ TYPE W/ 'CHAR_SEQ'
                    else:
                        self.append_LFIUD(first_inside_type)

                if len(self.LFIUD) == 1:   # IF ONE TYPE OF THING IN THE OUTER OBJECT
                    if self.LFIUD[0] == 'CHAR_SEQ':   # AND THAT TYPE OF THING IS A CHAR_SEQ TYPE
                        self.LFIUD.clear()   # HAS 'CHAR_SEQ' IN IT, CLEAR IT

                        try: self.UNIQUES = n.unique(self.LIST_OBJECT, return_counts=False)
                        except: self.UNIQUES = n.unique(self.LIST_OBJECT.astype(str), return_counts=False)

                        self.DUM_HOLDER = []
                        for unique in self.UNIQUES:
                            __ = vcsdt.ValidateCharSeqDataType(unique).type()[0]
                            self.DUM_HOLDER.append(__)  # BUILD THIS HERE IN CASE NEED IT FOR A LIST W MULTIPLE CHARSEQ TYPES
                            self.append_LFIUD(__)
                            self.append_LEOUD(__)
                        self.UNIQUES = []

                        # IF ONLY ONE TYPE OF CHAR_SEQ TYPE (FLOAT, INT, STR, ETC), TYPE IS CONSISTENT
                        if len(self.LFIUD) == 1:
                            self.list_type_desc = f'{xxx} OF {len(self.OBJECT)} {self.LFIUD[0]}(S)' # <===================================================
                            # LOTD UNCHANGED, NO LISTS INSIDE THIS LIST
                            break
                        elif len(self.LFIUD) > 1:
                            dum_str = '' # CREATE A DUMMY STRING & HOLDER TO REPORT WHAT TYPE OF CHAR_SEQS IN LFIUD
                            for ___ in self.LFIUD:
                                dum_str += f'{self.DUM_HOLDER.count(___)} {str(___)}(S), '
                            self.list_type_desc = f'{xxx} OF {dum_str[:-2]}'               # <===================================================
                            # LOTD UNCHANGED, NO LISTS INSIDE THIS LIST
                            break
                        else:
                            raise AssertionError(f'LIST_FIRST_IDXPOSN_UNIQUE_DATATYPES IS EMPTY BUT LEN(LIST_OBJECT) IS NOT ZERO.  TERMINAL ERROR.')
                        # LSIUD IS UNCHANGED
                        break

                    elif self.LFIUD[0].upper() in vmot.list_of_listtypes():   # WHEN THERE IS 1 INNER TYPE & ITS ALSO A LISTTYPE, EITHER THE SAME AS OR DIFFERENT FROM THE OUTER LISTTYPE
                        yyy = self.LFIUD[0].upper()  # INNER TYPE
                        ragged_dum = ''
                        LENGTH_DUM = []  #### DETERMINE THE LENGTH OF ALL THESE LISTTYPE OBJECTS INSIDE LIST_OBJECT
                        ### ALL LENS = 0, THEN ALL EMPTY, IF ANY DIFFERENT LENS, THEN RAGGED
                        [LENGTH_DUM.append(len(_)) for _ in self.OBJECT if len(_) not in LENGTH_DUM]
                        if len(LENGTH_DUM) == 1 and LENGTH_DUM[0] == 0:
                            self.list_type_desc = f'{xxx} of {len(self.OBJECT)} EMPTY {yyy}(S)'
                            for _ in range(len(self.LIST_OBJECT)):  # ADD THIS DIAGNOSIS FOR EACH ROW TO LOTD
                                self.LOTD.append(f'EMPTY {yyy}')  # <===================================================
                            break
                        elif len(LENGTH_DUM) > 1: ragged_dum = 'RAGGED '

                        for inner_idx in range(len(self.LIST_OBJECT)):  # WHEN THERES SOMETHING INSIDE THE INNER LISTTYPES (WOULD HAVE BROKE ABOVE IF ALL EMPTY)
                            self.LSIUD.append([])                       # FIND OUT WHAT THE UNIQUE TYPES ARE IN EACH LIST WITHIN LIST_OBJECT

                            self.UNIQUES = n.unique(self.LIST_OBJECT[inner_idx], return_counts=False)
                            for unique in self.UNIQUES:  # DOING IT OUT LIKE THIS INSTD OF append_SIUD() BECAUSE IT'S AN ODDBALL OPERATION
                                innermost_type = vmot.validate_modified_object_type(unique).upper()
                                if innermost_type in vmot.list_of_charseqs():
                                    self.append_LSIUD('CHAR_SEQ', inner_idx)             # REPLACING ANY CHAR_SEQTYPE W/ 'CHAR_SEQ'
                                else:
                                    self.append_LSIUD(innermost_type, inner_idx)
                            self.UNIQUES = []

                        # IF ALL THE THINGS INSIDE THE HOMOGENOUS INNER LISTTYPES ARE OF THE SAME TYPE
                                # IF ALL LENS ARE 1, SUM = TO LEN OF LIST_OBJECT           # SUM TO SOMETHING GREATER THAN 0 IF NOT ALL EQUAL
                        if sum([len(_) for _ in self.LSIUD if len(_) == 1]) == len(self.LSIUD) and sum([1 for _ in self.LSIUD if _[0] != self.LSIUD[0][0]]) == 0:

                            if self.LSIUD[0][0] == 'CHAR_SEQ':  # IF THEY ARE CHAR_SEQ TYPES
                                # NOW THAT WE KNOW THAT ALL THE INNER LISTS HOLD CHARSEQ-TYPES, FIND OUT WHAT THOSE TYPES ARE
                                self.LSIUD.clear()
                                for inner_idx in range(len(self.LIST_OBJECT)):
                                    self.LSIUD.append([])
                                    self.UNIQUES = n.unique(self.LIST_OBJECT[inner_idx], return_counts=False)
                                    for unique in self.UNIQUES:
                                        _ = vcsdt.ValidateCharSeqDataType(unique).type()[0]
                                        self.append_LEOUD(_)
                                        self.append_LSIUD(_, inner_idx)
                                    self.UNIQUES = []

                                if len(self.LEOUD) == 1:  #IF ONLY ONE TYPE OF DATA IN ALL LISTS
                                    self.list_type_desc = f'{ragged_dum}{xxx} OF {len(self.LIST_OBJECT)} {yyy}(S) OF {self.LEOUD[0]}S'  # <===================================================
                                    [self.LOTD.append(f'{yyy} OF {len(_)} {self.LEOUD[0]}(s)') for _ in self.LIST_OBJECT]
                                elif len(self.LEOUD) > 1 and sum([len(_) for _ in self.LSIUD if len(_) == 1]) == len(self.LSIUD): # MORE THAN 1 TYPE OF CHAR_SEQ, BUT ONLY 1 TYPE IN EACH LIST
                                    self.list_type_desc = f'{ragged_dum}{xxx} OF {len(self.LIST_OBJECT)} {yyy}(S) OF {"S, ".join(self.LEOUD)}S'
                                    [self.LOTD.append(f'{yyy} OF {len(self.LIST_OBJECT[idx])} {self.LSIUD[idx][0]}(S)') for idx in range(len(self.LIST_OBJECT))]
                                else:  # MORE THAN 1 TYPE OF CHAR_SEQ, AND AT LEAST 1 LIST HAS MORE THAN 1 TYPE OF CHAR_SEQ
                                    self.list_type_desc = f'{ragged_dum}{xxx} OF {len(self.LIST_OBJECT)} {yyy}(S) OF {"S, ".join(self.LEOUD)}S'
                                    [self.LOTD.append(f'{yyy} OF {len(self.LIST_OBJECT[idx])} {self.LSIUD[idx]}(S)') for idx in range(len(self.LIST_OBJECT))]
                                break
                            else:  # IF INNER LISTTYPES ARE HOLDING THE SAME KIND OF THING, BUT IT ISNT A CHARSEQ TYPE
                                self.append_LEOUD(self.LSIUD[0][0])
                                self.list_type_desc = f'ODDBALL {xxx} OF {len(self.LIST_OBJECT)} {yyy}(s) OF {self.LEOUD[0]}S'  # <===================================================
                                [self.LOTD.append(f'{yyy} OF {len(_)} {self.LEOUD[0]}(S)') for _ in self.LIST_OBJECT]
                                break
                        # WHEN THE INSIDES OF THE HOMOGENOUS INNER LIST TYPES ARE NOT OF THE SAME TYPE
                        else:  #TAKE UNIQUE NON-CHARSEQ TYPES OUT OF LSIUD PUT IN LEOUD, IF A CHAR_SEQ, RUN THRU VCSDT, THEN PUT UNIQUES IN LEOUD
                            for inner_idx in range(len(self.LSIUD)):
                                for innermost_idx in range(len(self.LSIUD[inner_idx])):
                                    _ = self.LSIUD[inner_idx][innermost_idx].upper()
                                    if _ != 'CHAR_SEQ':
                                        self.append_LEOUD(_)
                                    else:  # IF LSIUD'S COLUMN HAS A CHAR_SEQ IN ITS UNIQUES, GO TO CORRESPONDING LIST IN LIST_OBJECT AND RUN VALIDATION ON THOSE THAT ARE CHAR_SEQ
                                        self.LSIUD[inner_idx].remove('CHAR_SEQ')
                                        self.UNIQUES = n.unique(self.LIST_OBJECT[inner_idx], return_counts=False)
                                        for unique in self.UNIQUES:
                                            if vmot.validate_modified_object_type(unique).upper() in vmot.list_of_charseqs():
                                                self.append_LEOUD(vcsdt.ValidateCharSeqDataType(unique).type()[0])    # AND PUT UNIQUES IN LEOUD
                                        self.UNIQUES = []

                            self.list_type_desc = f'ODDBALL {ragged_dum}{xxx} OF {len(self.LIST_OBJECT)} {yyy}(S) CONTAINING {"S, ".join(self.LEOUD)}S'   # <===================================================
                            [self.LOTD.append(f'{yyy} OF {len(self.LIST_OBJECT[_])} {self.LSIUD[_]}') for _ in range(len(self.LIST_OBJECT))]   # <===================================================
                            break

                    else:  # IF THE INNARDS OF THE OUTER OBJECT HOMOGENOUS BUT ARE NOT CHAR_SEQS OR HOMOGENOUS LIST-TYPES,
                            # THEN IT'S AN ODDBALL WITH 1 TYPE OF INNARDS
                        yyy = self.LFIUD[0].upper()  # INNER TYPE
                        list_type_desc = f'ODDBALL {xxx} OF {len(self.OBJECT)} {yyy}(S)'  # <===================================================
                        [self.LOTD.append(f'{yyy} OF {len(self.LIST_OBJECT[_])} THING(S)') for _ in range(len(self.LIST_OBJECT))]  # <===================================================
                        # LSIUD GETS NO UPDATE
                        break

                elif len(self.LFIUD) > 1:      # IF MORE THAN 1 TYPE IN OUTER OBJECT
                    self.LFIUD.clear()
                    for idx in range(len(self.LIST_OBJECT)):
                        _ = self.LIST_OBJECT[idx]
                        __ = vmot.validate_modified_object_type(_).upper()

                        if __ not in vmot.list_of_charseqs():
                            self.append_LFIUD(__)
                            self.append_LEOUD(__)
                            self.LOTD.append(f'{__} OF LENGTH {len(_)}')

                        elif __ in vmot.list_of_charseqs():  # IF LIST_OBJECT HAS CHAR_SEQ, RUN CHARSEQ VALIDATION ON IT AND APPEND UNIQUES TO LFIUD, LEOUD
                            ___ = vcsdt.ValidateCharSeqDataType(_).type()[0].upper()
                            self.append_LEOUD(___)  # AND PUT UNIQUES IN LEOUD & LFIUD
                            self.append_LFIUD(___)
                            # IF IS A CHARSEQ, OVERWRITE __ WITH THE VALIDATED DATATYPE
                            self.LOTD.append(f'{___}')  # <===================================================

                    self.list_type_desc = f'ODDBALL {xxx} OF {len(self.LIST_OBJECT)} CONTAINING {"S, ".join(self.LFIUD)}S'  # <===================================================
                    break

        return self.list_type_desc, self.LFIUD, self.LSIUD, self.LEOUD, self.LOTD




