# Author:
#         Bill Sousa
#
# License: BSD 3 clause
#



from typing import (
    Optional,
    Sequence,
    Self
)
from ._type_aliases import (
    OverallStatisticsType,
    StartsWithFrequencyType,
    CharacterFrequencyType,
    WordFrequencyType,
    LongestWordsType,
    ShortestWordsType
)

import numbers
from copy import deepcopy

import numpy as np

from ._validation._words import _val_words
from ._validation._overall_statistics import _val_overall_statistics
from ._validation._uniques import _val_uniques
from ._validation._word_frequency import _val_word_frequency
from ._validation._startswith_frequency import _val_startswith_frequency
from ._validation._character_frequency import _val_character_frequency

from ._partial_fit._build_overall_statistics import _build_overall_statistics
from ._partial_fit._merge_overall_statistics import _merge_overall_statistics
from ._partial_fit._build_uniques import _build_uniques
from ._partial_fit._merge_uniques import _merge_uniques
from ._partial_fit._build_word_frequency import _build_word_frequency
from ._partial_fit._merge_word_frequency import _merge_word_frequency
from ._partial_fit._build_startswith_frequency import _build_startswith_frequency
from ._partial_fit._merge_startswith_frequency import _merge_startswith_frequency
from ._partial_fit._build_character_frequency import _build_character_frequency
from ._partial_fit._merge_character_frequency import _merge_character_frequency

from ._print._overall_statistics import _print_overall_statistics
from ._print._startswith_frequency import _print_starts_with_frequency
from ._print._word_frequency import _print_word_frequency
from ._print._character_frequency import _print_character_frequency
from ._print._uniques import _print_uniques
from ._print._longest_words import _print_longest_words
from ._print._shortest_words import _print_shortest_words

from ....base import (
    GetParamsMixin,
    ReprMixin,
    SetParamsMixin,
    check_is_fitted,
    validate_data
)



class TextStatistics(
    GetParamsMixin,
    ReprMixin,
    SetParamsMixin
):

    _lp: numbers.Integral = 5
    _rp: numbers.Integral = 15


    def __init__(
        self,
        case_sensitive: Optional[bool] = False,
        ignore_non_latin_characters: Optional[bool] = True
    ) -> None:

        """
        pizza finalize this.
        Generate statistics about a list of words. Returns
        nothing. Statistics include
        - size
        - uniques count
        - average length and standard deviation
        - max word length
        - min word length
        - 'starts with' frequency
        - letter frequency
        - top word frequencies
        - top longest words


        Parameters
        ----------
        case_sensitive:
            Optional[bool], default = False - whether to handle all
            letters as if they are the same case. When True, keep
            separate statistics for upper and lower-case letters; when
            False, ignore the case.
        ignore_non_latin_characters:
            Optional[bool], default = True, whether to keep statistics
            for non-Latin characters.



        Return
        ------
        -
            None

        """

        self.case_sensitive = case_sensitive
        self.ignore_non_latin_characters = ignore_non_latin_characters


    def __pybear_is_fitted__(self):

        """
        If an estimator/transformer does not set any attributes with a
        trailing underscore, it can define a '__pybear_is_fitted__' method
        returning a boolean to specify if the estimator/transformer is
        fitted or not.

        """

        # must have this because there are no trailing-underscore attrs
        # generated by {partial_}fit(). all the trailing-underscore attrs
        # are accessed via @property.
        return hasattr(self, '_overall_statistics')


    # v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
    # @properties v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v

    # overall_statistics_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def overall_statistics_(self) -> OverallStatisticsType:

        """
        A dictionary that holds information about all the strings fitted
        on the TextStatistics instance, such as average string length,
        maximum string length, total number of strings, etc.

        """

        check_is_fitted(self)

        return self._overall_statistics


    @overall_statistics_.setter
    def overall_statistics_(self, value):
        raise AttributeError(f'overall_statistics_ attribute is read-only')


    def print_overall_statistics(self) -> None:

        """Print the 'overall_statistics_' attribute to screen."""

        check_is_fitted(self)

        _print_overall_statistics(self._overall_statistics, self._lp, self._rp)

    # END overall_statistics_ -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # uniques_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def uniques_(self):

        """
        A sequence of the unique strings fitted on the TextStatistics
        instance.

        """

        check_is_fitted(self)

        return self._uniques


    @uniques_.setter
    def uniques_(self, value):
        raise AttributeError(f'overall_statistics_ attribute is read-only')


    def print_uniques(self) -> None:
        """Print the 'uniques_' attribute to the screen."""

        check_is_fitted(self)

        _print_uniques(self._uniques, self._lp, self._rp)

    # END uniques_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # starts_with_frequency_ -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def starts_with_frequency_(self) -> StartsWithFrequencyType:

        """
        A dictionary that holds the first characters and their frequencies
        for all the strings fitted on the TextStatistics instance.

        """

        check_is_fitted(self)

        return self._starts_with_frequency


    @starts_with_frequency_.setter
    def starts_with_frequency_(self, value):
        raise AttributeError(f'starts_with_frequency_ attribute is read-only')


    def print_starts_with_frequency(self) -> None:

        """Print the 'starts_with_frequency_' attribute to screen."""

        check_is_fitted(self)

        _print_starts_with_frequency(
            self._starts_with_frequency, self._lp, self._rp
        )

    # END starts_with_frequency_ -- -- -- -- -- -- -- -- -- -- -- -- --

    # character_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def character_frequency_(self) -> CharacterFrequencyType:

        check_is_fitted(self)

        return self._character_frequency


    @character_frequency_.setter
    def character_frequency_(self, value):
        raise AttributeError(f'character_frequency_ attribute is read-only')


    def print_character_frequency(self) -> None:

        """Print the 'character_frequency_' attribute to screen."""

        check_is_fitted(self)

        _print_character_frequency(
            self._character_frequency, self._lp, self._rp
        )

    # END character_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # word_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def word_frequency_(self) -> WordFrequencyType:

        """The unique strings seen and the number of occurrences."""

        check_is_fitted(self)

        return self._word_frequency


    @word_frequency_.setter
    def word_frequency_(self, value):
        raise AttributeError(f'word_frequency_ attribute is read-only')


    def print_word_frequency(
        self,
        n:Optional[numbers.Integral] = 10
    ) -> None:

        """Print the 'word_frequency_' attribute to screen."""

        check_is_fitted(self)

        err_msg = f"'n' must be an integer >= 1"
        if not isinstance(n, numbers.Integral):
            raise TypeError(err_msg)
        if isinstance(n, bool):
            raise TypeError(err_msg)
        if n < 1:
            raise ValueError(err_msg)
        del err_msg

        _print_word_frequency(
            self._word_frequency, self._lp, self._rp, n
        )

    # END word_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # longest_words -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ==
    @property
    def longest_words_(self) -> LongestWordsType:

        """The longest strings seen during fitting."""

        check_is_fitted(self)

        # pizza
        pass


    @longest_words_.setter
    def longest_words_(self, value):
        raise AttributeError(f'longest_words_ attribute is read-only')


    def print_longest_words(
        self,
        n: Optional[numbers.Integral] = 10
    ) -> None:

        """
        Print the 'longest_words_' attribute to screen.


        Parameters
        ----------
        n:
            Optional[numbers.Integral], default = 10 - the number of
            longest words to print to screen.


        Return
        ------
        -
            None


        """

        check_is_fitted(self)

        err_msg = f"'n' must be an integer >= 1"
        if not isinstance(n, numbers.Integral):
            raise TypeError(err_msg)
        if isinstance(n, bool):
            raise TypeError(err_msg)
        if n < 1:
            raise ValueError(err_msg)
        del err_msg

        _print_longest_words(self.longest_words_, self._lp, self._rp, n)

    # END longest_words -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # shortest_words -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def shortest_words_(self) -> ShortestWordsType:

        """The shortest strings seen during fitting."""

        check_is_fitted(self)

        # pizza
        pass


    @shortest_words_.setter
    def shortest_words_(self, value):
        raise AttributeError(f'shortest_words_ attribute is read-only')


    def print_shortest_words(
        self,
        n: Optional[numbers.Integral] = 10
    ) -> None:

        """
        Print the 'shortest_words_' attribute to screen.


        Parameters
        ----------
        n:
            Optional[numbers.Integral], default = 10 - the number of
            shortest strings to print to screen.

        Return
        ------
        -
            None

        """

        check_is_fitted(self)

        err_msg = f"'n' must be an integer >= 1"
        if not isinstance(n, numbers.Integral):
            raise TypeError(err_msg)
        if isinstance(n, bool):
            raise TypeError(err_msg)
        if n < 1:
            raise ValueError(err_msg)
        del err_msg

        _print_shortest_words(self.shortest_words_, self._lp, self._rp, n)

    # END shortest_words -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # END @properties v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
    # v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v


    def _reset(self):

        try:
            del self._word_frequency
            del self._uniques
            del self._overall_statistics
            del self._starts_with_frequency
            del self._character_frequency
        except:
            pass


    # pizza on the block!
    def _lowercase_dict(self):
        CHARS = list('abcdefghijklmnopqrstuvwxyz')  
        return dict((zip(CHARS, [0 for _ in range(26)])))

    # pizza on the block!
    def _uppercase_dict(self):
        CHARS = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
        return dict((zip(CHARS, [0 for _ in range(26)])))

    # pizza on the block!
    def _number_dict(self):
        return {}

    # pizza on the block!
    def _other_dict(self):
        return {
            'other':0
        }


    def partial_fit(self, WORDS: Sequence[str]) -> Self:

        """
        Batch-wise accumulation of statistics.


        Parameters
        ----------
        WORDS:
            Sequence[str] - a single list-like vector of words to report
            statistics for, cannot be empty. Words do not need to be in
            the Lexicon. Individual words cannot have spaces and must be
            under 30 characters in length.


        Return
        ------
        -
            self


        """

        # validation ** * ** * ** * ** * ** * ** * ** * ** * ** * ** * **

        validate_data(
            WORDS,
            copy_X=False,
            cast_to_ndarray=False,
            accept_sparse=None,
            dtype='any',
            require_all_finite=False,
            cast_inf_to_nan=False,
            standardize_nan=False,
            allowed_dimensionality=(1,),
            ensure_2d=False,
            order='C',
            ensure_min_features=1,
            ensure_max_features=1,
            ensure_min_samples=1,
            sample_check=None
        )

        _val_words(WORDS)

        # END validation ** * ** * ** * ** * ** * ** * ** * ** * ** * **

        # word_frequency_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        _current_word_frequency: dict[str, numbers.Integral] = \
            _build_word_frequency(
                WORDS,
                case_sensitive=self.case_sensitive
            )

        self._word_frequency: dict[str, numbers.Integral] = \
            _merge_word_frequency(
                _current_word_frequency,
                getattr(self, '_word_frequency', {})
            )

        del _current_word_frequency

        _val_word_frequency(self._word_frequency)
        # END word_frequency_ -- -- -- -- -- -- -- -- -- -- -- -- -- --

        # uniques -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        _current_uniques: Sequence[str] = \
            _build_uniques(
                WORDS,
                case_sensitive=self.case_sensitive
            )

        self._uniques: Sequence[str] = \
            _merge_uniques(
                _current_uniques,
                self._uniques
            )

        del _current_uniques

        _val_uniques(self._uniques)
        # END uniques -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

        # overall_statistics_ -- -- -- -- -- -- -- -- -- -- -- -- -- --
        _current_overall_statistics: dict[str, numbers.Real] = \
            _build_overall_statistics(
                WORDS,
                case_sensitive=self.case_sensitive
            )

        self._overall_statistics: dict[str, numbers.Real] = \
            _merge_overall_statistics(
                _current_overall_statistics,
                getattr(self, '_overall_statistics', {}),
                len(self._uniques)
            )

        del _current_overall_statistics

        _val_overall_statistics(self._overall_statistics)
        # END overall_statistics_ -- -- -- -- -- -- -- -- -- -- -- -- --

        # startswith_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- --
        _current_starts_with_frequency = \
            _build_startswith_frequency(
                self._word_frequency
            )
        self._starts_with_frequency: dict[str, numbers.Integral] = \
            _merge_startswith_frequency(
                _current_starts_with_frequency,
                getattr(self, '_starts_with_frequency', {})
            )

        del _current_starts_with_frequency

        _val_startswith_frequency(self._starts_with_frequency)
        # END startswith_frequency -- -- -- -- -- -- -- -- -- -- -- --


        # character_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- --
        _current_character_frequency: dict[str, numbers.Integral] = \
            _build_character_frequency(
                self._word_frequency
            )

        self._character_frequency: dict[str, numbers.Integral] = \
            _merge_character_frequency(
                _current_character_frequency,
                getattr(self, '_character_frequency', {})
            )

        del _current_character_frequency

        _val_character_frequency(self._character_frequency)
        # END character_frequency -- -- -- -- -- -- -- -- -- -- -- -- --


    def fit(self, WORDS: Sequence[str]):

        """
        Get statistics for one sequence of words.


        Parameters
        ----------
        WORDS:
            Sequence[str] - a single list-like vector of words to report
            statistics for, cannot be empty. Words do not need to be in
            the Lexicon. Individual words cannot have spaces and must be
            under 30 characters in length.


        Return
        ------
        -
            self


        """

        self._reset()

        return self.partial_fit(WORDS)














