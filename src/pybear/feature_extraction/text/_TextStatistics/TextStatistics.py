# Author:
#         Bill Sousa
#
# License: BSD 3 clause
#



from typing import (
    Optional,
    Sequence,
    Self
)
from ._type_aliases import (
    OverallStatisticsType,
    StartsWithFrequencyType,
    CharacterFrequencyType,
    WordFrequencyType,
    LongestWordsType,
    ShortestWordsType
)
import numpy.typing as npt

import numbers

import numpy as np

from ._validation._words import _val_words
from ._validation._overall_statistics import _val_overall_statistics
from ._validation._uniques import _val_uniques
from ._validation._word_frequency import _val_word_frequency
from ._validation._startswith_frequency import _val_startswith_frequency
from ._validation._character_frequency import _val_character_frequency
from ._validation._n import _val_n

from ._partial_fit._build_overall_statistics import _build_overall_statistics
from ._partial_fit._merge_overall_statistics import _merge_overall_statistics
from ._partial_fit._build_word_frequency import _build_word_frequency
from ._partial_fit._merge_word_frequency import _merge_word_frequency
from ._partial_fit._build_startswith_frequency import _build_startswith_frequency
from ._partial_fit._merge_startswith_frequency import _merge_startswith_frequency
from ._partial_fit._build_character_frequency import _build_character_frequency
from ._partial_fit._merge_character_frequency import _merge_character_frequency

from ._print._overall_statistics import _print_overall_statistics
from ._print._startswith_frequency import _print_starts_with_frequency
from ._print._word_frequency import _print_word_frequency
from ._print._character_frequency import _print_character_frequency
from ._print._longest_words import _print_longest_words
from ._print._shortest_words import _print_shortest_words

from ._get._get_longest_words import _get_longest_words
from ._get._get_shortest_words import _get_shortest_words

from ._lookup._lookup_substring import _lookup_substring
from ._lookup._lookup_string import _lookup_string

from ....base import (
    ReprMixin,
    check_is_fitted
)



class TextStatistics(ReprMixin):

    _lp: numbers.Integral = 5
    _rp: numbers.Integral = 15


    def __init__(self) -> None:

        """
        pizza finalize this.
        Generate statistics about a list of words. Returns
        nothing. Statistics include
        - size
        - uniques count
        - average length and standard deviation
        - max word length
        - min word length
        - 'starts with' frequency
        - letter frequency
        - top word frequencies
        - top longest words


        Return
        ------
        -
            None

        """


    def __pybear_is_fitted__(self):

        """
        If an estimator/transformer does not set any attributes with a
        trailing underscore, it can define a '__pybear_is_fitted__' method
        returning a boolean to specify if the estimator/transformer is
        fitted or not.

        """

        # must have this because there are no trailing-underscore attrs
        # generated by {partial_}fit(). all the trailing-underscore attrs
        # are accessed via @property.
        return hasattr(self, '_overall_statistics')


    # v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
    # @properties v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v

    # size_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def size_(self) -> numbers.Integral:

        """The number of strings fitted on the TextStatistics instance."""

        check_is_fitted(self)

        return self.overall_statistics_['size']


    @size_.setter
    def size_(self, value):
        raise AttributeError(f'size_ attribute is read-only')
    # END size_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # overall_statistics_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def overall_statistics_(self) -> OverallStatisticsType:

        """
        A dictionary that holds information about all the strings fitted
        on the TextStatistics instance, such as average string length,
        maximum string length, total number of strings, etc.

        """

        check_is_fitted(self)

        return self._overall_statistics


    @overall_statistics_.setter
    def overall_statistics_(self, value):
        raise AttributeError(f'overall_statistics_ attribute is read-only')
    # END overall_statistics_ -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # uniques_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def uniques_(self) -> Sequence[str]:  # pizza want ndarray here?

        """
        A list of the unique strings fitted on the TextStatistics
        instance.

        """

        check_is_fitted(self)

        uniques = list(self._word_frequency.keys())

        _val_uniques(uniques)

        return uniques


    @uniques_.setter
    def uniques_(self, value):
        raise AttributeError(f'overall_statistics_ attribute is read-only')
    # END uniques_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # starts_with_frequency_ -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def starts_with_frequency_(self) -> StartsWithFrequencyType:

        # pizza make a decision ... starts_with_frequency or startswith_frequency

        """
        A dictionary that holds the first characters and their frequencies
        for all the strings fitted on the TextStatistics instance.

        """

        check_is_fitted(self)

        return self._starts_with_frequency


    @starts_with_frequency_.setter
    def starts_with_frequency_(self, value):
        raise AttributeError(f'starts_with_frequency_ attribute is read-only')
    # END starts_with_frequency_ -- -- -- -- -- -- -- -- -- -- -- -- --

    # character_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def character_frequency_(self) -> CharacterFrequencyType:

        check_is_fitted(self)

        return self._character_frequency


    @character_frequency_.setter
    def character_frequency_(self, value):
        raise AttributeError(f'character_frequency_ attribute is read-only')
    # END character_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # word_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    @property
    def word_frequency_(self) -> WordFrequencyType:

        """The unique strings seen and the number of occurrences."""

        check_is_fitted(self)

        return self._word_frequency


    @word_frequency_.setter
    def word_frequency_(self, value):
        raise AttributeError(f'word_frequency_ attribute is read-only')
    # END word_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # END @properties v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
    # v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v


    def _reset(self):

        try:
            del self._word_frequency
            del self._overall_statistics
            del self._starts_with_frequency
            del self._character_frequency
        except:
            pass



    def partial_fit(
        self,
        WORDS: Sequence[str],
        y: Optional[any] = None
    ) -> Self:

        """
        Batch-wise accumulation of statistics.


        Parameters
        ----------
        WORDS:
            Sequence[str] - a single list-like vector of words to report
            statistics for, cannot be empty. Words do not need to be in
            the Lexicon. Individual words cannot have spaces and must be
            under 30 characters in length.
        y:
            Optional[any], default = None - a target for the data. Always
            ignored.


        Return
        ------
        -
            self


        """

        _val_words(WORDS)

        # word_frequency_ -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        # this must be before overall_statistics
        _current_word_frequency: dict[str, numbers.Integral] = \
            _build_word_frequency(
                WORDS,
                case_sensitive=True
            )

        self._word_frequency: dict[str, numbers.Integral] = \
            _merge_word_frequency(
                _current_word_frequency,
                getattr(self, '_word_frequency', {})
            )

        del _current_word_frequency

        _val_word_frequency(self._word_frequency)
        # END word_frequency_ -- -- -- -- -- -- -- -- -- -- -- -- -- --

        # overall_statistics_ -- -- -- -- -- -- -- -- -- -- -- -- -- --
        _current_overall_statistics: dict[str, numbers.Real] = \
            _build_overall_statistics(
                WORDS,
                case_sensitive=True
            )

        self._overall_statistics: dict[str, numbers.Real] = \
            _merge_overall_statistics(
                _current_overall_statistics,
                getattr(self, '_overall_statistics', {}),
                len(self._word_frequency)
            )

        del _current_overall_statistics

        _val_overall_statistics(self._overall_statistics)
        # END overall_statistics_ -- -- -- -- -- -- -- -- -- -- -- -- --

        # startswith_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- --
        _current_starts_with_frequency = \
            _build_startswith_frequency(
                self._word_frequency
            )
        self._starts_with_frequency: dict[str, numbers.Integral] = \
            _merge_startswith_frequency(
                _current_starts_with_frequency,
                getattr(self, '_starts_with_frequency', {})
            )

        del _current_starts_with_frequency

        _val_startswith_frequency(self._starts_with_frequency)
        # END startswith_frequency -- -- -- -- -- -- -- -- -- -- -- --


        # character_frequency -- -- -- -- -- -- -- -- -- -- -- -- -- --
        _current_character_frequency: dict[str, numbers.Integral] = \
            _build_character_frequency(
                self._word_frequency
            )

        self._character_frequency: dict[str, numbers.Integral] = \
            _merge_character_frequency(
                _current_character_frequency,
                getattr(self, '_character_frequency', {})
            )

        del _current_character_frequency

        _val_character_frequency(self._character_frequency)
        # END character_frequency -- -- -- -- -- -- -- -- -- -- -- -- --

        return self


    def fit(
        self,
        WORDS: Sequence[str],
        y: Optional[any] = None
    ) -> Self:

        """
        Get statistics for one sequence of words.


        Parameters
        ----------
        WORDS:
            Sequence[str] - a single list-like vector of words to report
            statistics for, cannot be empty. Words do not need to be in
            the Lexicon. Individual words cannot have spaces and must be
            under 30 characters in length.
        y:
            Optional[any], default = None - a target for the data. Always
            ignored.


        Return
        ------
        -
            self


        """

        self._reset()

        return self.partial_fit(WORDS)



    # OTHER METHODS v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^

    def print_overall_statistics(self) -> None:

        """Print the 'overall_statistics_' attribute to screen."""

        check_is_fitted(self)

        _print_overall_statistics(self._overall_statistics, self._lp, self._rp)


    def print_starts_with_frequency(self) -> None:

        """Print the 'starts_with_frequency_' attribute to screen."""

        check_is_fitted(self)

        _print_starts_with_frequency(
            self._starts_with_frequency, self._lp, self._rp
        )


    def print_character_frequency(self) -> None:

        """Print the 'character_frequency_' attribute to screen."""

        check_is_fitted(self)

        _print_character_frequency(self._character_frequency, self._lp, self._rp)


    def print_word_frequency(
        self,
        n:Optional[numbers.Integral] = 10
    ) -> None:

        """
        Print the 'word_frequency_' attribute to screen.


        Parameters
        ----------
        n:
            Optional[numbers.Integral], default = 10 - the number of the
            most frequent strings to print to screen.


        Return
        ------
        -
            None

        """

        check_is_fitted(self)

        _print_word_frequency(self._word_frequency, self._lp, self._rp, n)


    # pizza make a decision ... 'words' or 'strings'

    # longest_words -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ==
    def get_longest_words(
        self,
        n: Optional[numbers.Integral] = 10
    ) -> LongestWordsType:

        """
        The longest strings seen by the TextStatistics instance during
        fitting.


        Parameters
        ----------
        n:
            Optional[numbers.Integral], default = 10 - the number of the
            top longest strings to return.


        Return
        ------
        -
            dict[str, numbers.Integral] - the top 'n' longest strings
            seen by the TextStatistics instance during fitting.


        """

        check_is_fitted(self)

        return _get_longest_words(self._word_frequency, n=n)


    def print_longest_words(
        self,
        n: Optional[numbers.Integral] = 10
    ) -> None:

        """
        Print the longest strings in the 'word_frequency_' attribute to
        screen.


        Parameters
        ----------
        n:
            Optional[numbers.Integral], default = 10 - the number of top
            longest strings to print to screen.


        Return
        ------
        -
            None


        """

        check_is_fitted(self)

        _print_longest_words(self._word_frequency, self._lp, self._rp, n)
    # END longest_words -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

    # shortest_words -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    def get_shortest_words(
        self,
        n: Optional[numbers.Integral] = 10
    ) -> ShortestWordsType:

        """
        The shortest strings seen by the TextStatistics instance during
        fitting.


        Parameters
        ----------
        n:
            Optional[numbers.Integral], default = 10 - the number of the
            top shortest strings to return.


        Return
        ------
        -
            dict[str, numbers.Integral] - the top 'n' shortest strings
            seen by the TextStatistics instance during fitting.


        """

        check_is_fitted(self)

        return _get_shortest_words(self._word_frequency, n=n)


    def print_shortest_words(
        self,
        n: Optional[numbers.Integral] = 10
    ) -> None:

        """
        Print the shortest strings in the 'word_frequency_' attribute to
        screen.


        Parameters
        ----------
        n:
            Optional[numbers.Integral], default = 10 - the number of
            shortest strings to print to screen.

        Return
        ------
        -
            None

        """

        check_is_fitted(self)

        _print_shortest_words(self._word_frequency, self._lp, self._rp, n)

    # END shortest_words -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --



    def lookup_substring(
        self,
        char_seq: str,
        case_sensitive: Optional[bool] = True
    ) -> Sequence[str]:   # pizza want ndarray here?

        """
        Return a sequence of all strings that have been fitted on the
        TextStatistics instance that contain the given character
        substring.


        Parameters
        ----------
        char_seq:
            str - character substring to be looked up against the
            strings fitted on the TextStatistics instance.
        case_sensitive:
            Optional[bool], default = True - If True, search for the
            exact string in the fitted data. If False, normalize both
            the given string and the strings fitted on the TextStatistics
            instance, then perform the search.


        Return
        ------
        -
            matching_strings: Sequence[str] - sequence of all strings in
            the fitted data that contain the given character substring.
            Returns an empty sequence if there are no matches.


        """

        check_is_fitted(self)

        return _lookup_substring(char_seq, self.uniques_, case_sensitive)


    def lookup_string(
        self,
        char_seq: str,
        case_sensitive: Optional[bool]=False
    ) -> Sequence[str]:   # pizza want ndarray here?

        """
        Look in the fitted strings for a full character sequence (not a
        substring) that exactly matches the given character sequence. If
        the case_sensitive parameter is True, look for an identical match
        to the given character sequence, and if at least one is found,
        return that character string. If an exact match is not found,
        return None. If the case_sensitive parameter is False, normalize
        the strings seen by the TextStatistics instance and the given
        character string and search for matches. If matches are found,
        return a 1D sequence of the matches in their original form from
        the fitted data (there may be different capitalizations in the
        fitted data, so there may be multiple entries.) If no matches
        are found, return None.


        Parameters
        ----------
        char_seq:
            str - character string to be looked up against the strings
            fitted on the TextStatistics instance.
        case_sensitive:
            Optional[bool], default = True - If True, search for the
            exact string in the fitted data. If False, normalize both
            the given string and the strings fitted on the TextStatistics
            instance, then perform the search.


        Return
        ------
        -
            Union[str, Sequence[str], None] - if there are any matches,
            return the matching string(s) from the originally fitted
            data; if there are no matches, return None.


        """


        check_is_fitted(self)

        return _lookup_string(char_seq, self.uniques_, case_sensitive)


    def score(self, X: any, y: Optional[any] = None) -> None:

        """
        Dummy method to spoof dask Incremental and ParallelPostFit
        wrappers. Verified must be here for dask wrappers.
        """

        check_is_fitted(self)

        return






