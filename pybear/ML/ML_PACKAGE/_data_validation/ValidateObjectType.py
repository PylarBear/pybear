from ML_PACKAGE._data_validation import validate_modified_object_type as vmot, ValidateCharSeqDataType as vcsdt, \
    ValidateList as vl


# modified_object_type IS THE "TYPE" PULLED FROM THE PYTHON TYPE ---- str(type(OBJECT))
# object_type IS GROUPINGS OF modified_object_type, CHAR_SEQs, LISTTYPES, ET AL (USED FOR SIMPLICITY OF IF STATEMENTS)
# data_type IS THE "TYPE" GENERATED BY ValidateCharSeqDataType
#

# CALLED BY debug.identify_object_and_print.... BE SURE TO CHECK HOW THIS IS CALLED IN category_splitter
class ValidateObjectType:

    def __init__(self, OBJECT):
        self.OBJECT = OBJECT
        self.ENTIRE_OBJECT_UNIQUE_DATATYPES = []
        self.FIRST_IDXPOSN_UNIQUE_DATATYPES = []
        self.SECOND_IDXPOSN_UNIQUE_DATATYPES = []
        self.TD = [] # TYPE DESCRIPTIONS


    def append_EOUD(self, _):
        if _ not in self.ENTIRE_OBJECT_UNIQUE_DATATYPES:
            self.ENTIRE_OBJECT_UNIQUE_DATATYPES.append(_)


    def append_FIUD(self, _):
        if _ not in self.FIRST_IDXPOSN_UNIQUE_DATATYPES:
            self.FIRST_IDXPOSN_UNIQUE_DATATYPES.append(_)


    def append_SIUD(self, _, __):
        if _ not in self.SECOND_IDXPOSN_UNIQUE_DATATYPES[__]:
            self.SECOND_IDXPOSN_UNIQUE_DATATYPES[__].append(_)

    # CHAR_SEQ, DATAFRAME, DATAFRAMECOLUMN, DICT ARE ALL HERE AS FXNS UNDER THIS CLASS, BUT LIST IS A SEPARATE CLASS,
    # SO THAT UNIQUE INSTANCES CAN BE CREATED IF LISTS ARE INSIDE A LIST, OR LISTS ARE INSIDE A DICTIONARY


    def run_charseqs(self, _):  # THINK ITS DONE ######################################################################
        data_type = vcsdt.ValidateCharSeqDataType(_).type()[0]
        self.type_desc = f'CHAR_SEQ, PYTHON TYPE = {vmot.validate_modified_object_type(_)}, VALIDATED TYPE = {data_type}'
        self.append_EOUD(data_type)
        self.append_FIUD(data_type)
        # NO CHANGES TO SECOND_IDXPOSN_UNIQUE_DATATYPES
        return self.type_desc


    def run_dataframe(self):
        DF_COLS = [_ for _ in self.OBJECT]
        if len(DF_COLS) == 0:
            self.type_desc = f'EMPTY DATAFRAME'
            self.FIRST_IDXPOSN_UNIQUE_DATATYPES = ['DATAFRAME COLUMN']
            self.ENTIRE_OBJECT_UNIQUE_DATATYPES = ['']
            self.SECOND_IDXPOSN_UNIQUE_DATATYPES = ['']

        else:
            self.type_desc = f'DATAFRAME WITH {len(DF_COLS)} COLUMN(S) AND {len(self.OBJECT[DF_COLS[0]])} ROW(S)'
            self.FIRST_IDXPOSN_UNIQUE_DATATYPES = ['DATAFRAME COLUMN']
            for col_idx in range(len(DF_COLS)):
                self.SECOND_IDXPOSN_UNIQUE_DATATYPES.append([])  # PUT A COLUMN IN S.I.U.D. FOR EACH COLUMN IN DF
                for data_point in self.OBJECT[DF_COLS[col_idx]]:
                    __ = vcsdt.ValidateCharSeqDataType(data_point).type()[0]  # DF CAN ONLY BE 'CHAR-SEQ' TYPE, DONT NEED TO RUN PYTHON TYPE CHECK HERE
                    self.append_EOUD(__)
                    self.append_SIUD(__, col_idx)

        return self.type_desc, self.FIRST_IDXPOSN_UNIQUE_DATATYPES, self.SECOND_IDXPOSN_UNIQUE_DATATYPES, self.ENTIRE_OBJECT_UNIQUE_DATATYPES


    def run_dataframecolumn(self):   # THINK ITS DONE ######################################################################
        while True:
            if len(self.OBJECT) == 0:
                self.type_desc = f'EMPTY DATAFRAME COLUMN'
                # NO CHANGE TO ENTIRE_OBJECT_UNIQUE_DATATYPES
                # NO CHANGE TO FIRST_IDXPOSN_UNIQUE_DATATYPES
                # NO CHANGE TO SECOND_IDXPOSN_UNIQUE_DATATYPES
                break
            else:
                for row in self.OBJECT:
                    _ = vcsdt.ValidateCharSeqDataType(row).type()[0]  # DF CAN ONLY BE 'CHAR-SEQ' TYPE, DONT NEED TO RUN PYTHON TYPE CHECK HERE
                    self.append_EOUD(_)
                    self.append_FIUD(_)
                    # NO CHANGE TO SECOND_IDXPOSN_UNIQUE_DATATYPES

                self.type_desc = f'DATAFRAME COLUMN WITH {len(self.OBJECT)} ROWS OF {[str(_)+"(s)" for _ in self.FIRST_IDXPOSN_UNIQUE_DATATYPES]}'

                break
        return self.type_desc, self.FIRST_IDXPOSN_UNIQUE_DATATYPES, self. SECOND_IDXPOSN_UNIQUE_DATATYPES, self.ENTIRE_OBJECT_UNIQUE_DATATYPES


    def run_dictionary(self):  # NEEDS WORK TRY TO GET LIST FILL FXNS IN HERE ################################################
        DICT_ENTRIES = list(self.OBJECT.keys())
        if len(DICT_ENTRIES) == 0:
            # NO CHANGE TO ENTIRE_OBJECT_UNIQUE_DATATYPES
            # NO CHANGE TO FIRST_IDXPOSN_UNIQUE_DATATYPES
            # NO CHANGE TO SECOND_IDXPOSN_UNIQUE_DATATYPES
            self.type_desc = f'EMPTY DICTIONARY'

        else:
            [self.SECOND_IDXPOSN_UNIQUE_DATATYPES.append([]) for idx in range(len(self.OBJECT))]  # PUT A COLUMN IN S.I.U.D. FOR EACH ENTRY IN DICT

            for entry_idx in range(len(DICT_ENTRIES)):  # FIND OUT THE DIFF TYPES OF STUFF IN THE DICT
                _ = vmot.validate_modified_object_type(self.OBJECT[DICT_ENTRIES[entry_idx]]).upper()
                if _ in vmot.list_of_charseqs():
                    _ = vcsdt.ValidateCharSeqDataType(_).type()[0]
                # THIS ACCOMODATES THE FACT THAT A DICT CAN HOLD ANYTHING, SO IF A NON-CHARTYPE, PUT IN FIUD, BUT IF IS CHARTYPE,
                # LOOK UP THE VALIDATED CHARTYPE AND PUT THAT IN FIUD INSTEAD
                self.append_FIUD(_)
                if len(self.FIRST_IDXPOSN_UNIQUE_DATATYPES) > 1:  # ONCE LEN IS GREATER THAN 1, JUST STOP HERE AND GO RIGHT TO MORE IN DEPTH
                    break                                         # ANALYSIS OF EACH idx IN DICT

            if len(self.FIRST_IDXPOSN_UNIQUE_DATATYPES) == 1:
                _ = self.FIRST_IDXPOSN_UNIQUE_DATATYPES[0]
                if _ in vmot.list_of_charseqs():
                    self.ENTIRE_OBJECT_UNIQUE_DATATYPES = self.FIRST_IDXPOSN_UNIQUE_DATATYPES.copy()
                    # NO CHANGE TO SECOND_IDXPOSN_UNIQUE_DATATYPES
                    self.type_desc = f'DICTIONARY WITH {len(DICT_ENTRIES)} ENTRIES, ALL CHARSEQS OF TYPE {self.ENTIRE_OBJECT_UNIQUE_DATATYPES[0]}'
                    [self.TD.append(_) for idx in DICT_ENTRIES]
                elif _ in vmot.list_of_listtypes():  # KEEPING THIS SEPARATE, ENVISION BEING ABLE TO DESCRIBE THESE LISTS LIKE "A NUMPY OF 100 FLOAT(S)"
                    for entry_idx in range(len(DICT_ENTRIES)):
                        # self.SECOND_IDXPOSN_UNIQUE_DATATYPES.append([])
                        list_type_desc, LFIUD, LSIUD, LEOUD, LTUD = vl.ValidateList(self.OBJECT[DICT_ENTRIES[entry_idx]]).run()
                        # self.append_SIUD(list_type_desc, entry_idx)
                        self.append_EOUD(list_type_desc)
                        self.TD.append(list_type_desc)
                    self.type_desc = f'DICTIONARY WITH {len(DICT_ENTRIES)} ENTRIES, ALL {_}S OF {"S, ".join(LFIUD)}S'
                elif _ == 'DATAFRAME':
                    for entry_idx in DICT_ENTRIES:
                        type_desc, FUID, SIUD, EOUD = self.run_dataframe(self.OBJECT[DICT_ENTRIES[entry_idx]])
                        self.append_SIUD(type_desc)
                        self.append_EOUD(type_desc)
                        self.TD.append(type_desc)
                    self.type_desc = f'DICTIONARY WITH {len(DICT_ENTRIES)} ENTRIES, ALL DATAFRAMES HOLDING {"S, ".join(EOUD)}S'
                else: # ONE TYPE OF THING IN THE DICTIONARY, BUT NOT A CHAR_SEQTYPE, LISTTYPE, OR DATAFRAMES
                    self.append_FIUD(_)  # FOR THINGS THAT ARENT STR-TYPES OR LIST-TYPES
                    self.append_EOUD(_)
                    # NO CHANGE TO SECOND_IDXPOSN_UNIQUE_DATATYPES
                    self.type_desc = f'ODDBALL DICTIONARY WITH {len(DICT_ENTRIES)} ENTRIES, OF TYPE {_}'
                    [self.TD.append(_) for _ in [DICT_ENTRIES]]

            elif len(self.FIRST_IDXPOSN_UNIQUE_DATATYPES) > 1: # MULTIPLE THINGS IN THE DICTIONARY
                self.FIRST_IDXPOSN_UNIQUE_DATATYPES.clear()
                for entry_idx in range(len(DICT_ENTRIES)):
                    _ = vmot.validate_modified_object_type(self.OBJECT[DICT_ENTRIES[entry_idx]])
                    if _ in vmot.list_of_charseqs():
                        _ = vcsdt.ValidateCharSeqDataType(_).type()[0]
                        self.TD.append(_)
                    elif _ in vmot.list_of_listtypes():
                        list_type_desc, LFIUD, LSIUD, LEOUD, LTUD = vl.ValidateList(self.OBJECT[DICT_ENTRIES[entry_idx]]).run()
                        self.TD.append(list_type_desc)
                    elif _ == 'DATAFRAME':
                        type_desc, FUID, SIUD, EOUD = self.run_dataframe(self.OBJECT[DICT_ENTRIES[entry_idx]])
                        self.TD.append(type_desc)
                    else:
                        self.TD.append(f'{_} OF LENGTH {len(self.OBJECT[DICT_ENTRIES[entry_idx]])}')
                    self.append_FIUD(_)  # NO MATTER WHAT, FIUD & EOUD ALWAYS GET APPENDED W UNIQUE DATATYPE
                    self.append_EOUD(_)
                # ADDING THIS ON 11-27-2021, NOT SURE ABOUT THIS THO
                self.type_desc = f'ODDBALL DICTIONARY WITH {len(DICT_ENTRIES)} ENTRIES, OF TYPE {",".join(EOUD)}'
                # END 11-27-2021

        return self.type_desc, self.FIRST_IDXPOSN_UNIQUE_DATATYPES, self.SECOND_IDXPOSN_UNIQUE_DATATYPES, self.ENTIRE_OBJECT_UNIQUE_DATATYPES, self.TD


    #CALLED BY splitter_config
    def validate_object_type(self):
        # SET THIS UP TO HANDLE LIST, TUPLE, SET, NUMPY, DF, DF COLUMN, DICT, OR CHAR_SEQs

        # DETERMINE IF "object" IS A CHAR-SEQ, DF, DF COLUMN, DICTIONARY, OR LIST-TYPE (NUMPY, LIST, SET, TUPLE)
        self.modified_object_type = vmot.validate_modified_object_type(self.OBJECT)

        ############## DONE ################################################################################################
        if self.modified_object_type in vmot.list_of_charseqs():   # CAN HAVE ONLY ONE DATA TYPE, BECAUSE IT'S ONLY ONE OBJECT
            self.type_desc = self.run_charseqs(self.OBJECT)

        ####################################################################################################################
        ####### NEEDS WORK #################################################################################################
        # IF object IS A LIST-TYPE, DETERMINE IF IT IS A SINGLE LIST OR A LIST OF LISTS
        # FIND HOW MANY UNIQUE TYPES OF DATA & UNIQUE VALUES
        elif self.modified_object_type in vmot.list_of_listtypes():
            # REMEMBER THAT self.type_desc WAS self.list_type_desc
            self.type_desc, self.FIRST_IDXPOSN_UNIQUE_DATATYPES, self.SECOND_IDXPOSN_UNIQUE_DATATYPES, \
                self.ENTIRE_OBJECT_UNIQUE_DATATYPES, self.TD = vl.ValidateList(self.OBJECT).run()

        #####################################################################################################################
        ####### DONE #################################################################################################
        elif self.modified_object_type == 'DATAFRAME':     # CAN HAVE MULTIPLE DATA TYPES
            self.type_desc, self.FIRST_IDXPOSN_UNIQUE_DATATYPES, self.SECOND_IDXPOSN_UNIQUE_DATATYPES, self.ENTIRE_OBJECT_UNIQUE_DATATYPES = \
            self.run_dataframe()
        #####################################################################################################################
        ####### DONE #################################################################################################
        elif self.modified_object_type == 'DATAFRAME COLUMN':   # CAN HAVE ONLY ONE DATA TYPE
            self.type_desc, self.FIRST_IDXPOSN_UNIQUE_DATATYPES, self.SECOND_IDXPOSN_UNIQUE_DATATYPES, self.ENTIRE_OBJECT_UNIQUE_DATATYPES = \
                self.run_dataframecolumn()
        #####################################################################################################################
        ####### DONE ######################################################################################################
        elif self.modified_object_type == 'DICTIONARY':   # CAN HAVE MULTIPLE DATA TYPES
            self.type_desc, self.FIRST_IDXPOSN_UNIQUE_DATATYPES, self.SECOND_IDXPOSN_UNIQUE_DATATYPES, self.ENTIRE_OBJECT_UNIQUE_DATATYPES, self.TD = \
                self.run_dictionary()
        #####################################################################################################################
        elif self.modified_object_type == 'FUNCTION':
            self.type_desc = 'FUNCTION'
            print(f'NOT CONFIGURED FOR FUNCTIONS YET :(')
            pass

        elif self.modified_object_type == 'NOT RECOGNIZED':
            self.type_desc = 'NOT RECOGNIZED'
            print(f'PASSED OBJECT IS OF UNKNOWN TYPE')
            pass

        else:
            self.type_desc = 'UNKNOWN'
            print('UNKNOWN modified_object_type RETURNED FROM validate_modified_object_type()')

        return self.type_desc, self.ENTIRE_OBJECT_UNIQUE_DATATYPES, self.TD


    def ml_package_object_type(self, suppress_print='Y'):
        OUD = self.validate_object_type()[1]

        while True:
            if len(OUD)==1:
                data_type = OUD[0]
                if suppress_print == 'N':
                    print(f'Data type is {data_type}.')
                break

            if 'STR' in OUD: data_type = 'STR'
            elif 'FLOAT' in OUD: data_type = 'FLOAT'
            elif 'INT' in OUD: data_type = 'INT'
            else:
                # THIS IS A COP OUT, JUST THROWING ANYTHING ELSE INTO 'STR' FOR NOW, DONT WANT TO SPEND FOREVER AT 5:40 PM 2-19-22
                # COMING UP WITH EVERY POSSIBILITY FOR DATE, CURRENCY, ETC.
                data_type = 'STR'

            if suppress_print == 'N':
                text = ''
                for _ in OUD:
                    text += f'{_}, '
                print(f'Data type is a mix of {text[:-2]}.  Treating as {data_type}.')

            break

        # if data_type in ['SINGLE_LIST','CHAR_SEQ']:
        #     print(f'Number of values: {len(object)}')
        # elif data_type == 'LIST_OF_LISTS':
        #     print(f'Number of values: {len(object[0])}')

        return data_type  # 10-13-2021 category_splitter IS LOOKING FOR 'INT' 'FLOAT' OR 'STR' FROM THIS OUTPUT



